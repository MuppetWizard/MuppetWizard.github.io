[{"title":"第一一篇","url":"/2021/03/06/第一一篇/","content":"\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b51ce98510514b319952f3713eba566c~tplv-k3u1fbpfcp-watermark.image)\n\n# Kotlin学习-基础篇\n>本文是本人在学习 Koitlin 期间记录的一些知识点，仅作参考，如有错误，欢迎指正\n## 1、变量\n`val` (value的简写) 用来声明一个不可变的变量，对应Java中的 `final` 变量  \n`var` (variable的简写) 用来声明一个可变的变量，对应Java中的非 `final` 变量  \n<!--more-->\n当Kotlin无法自动推导变量类型时，需要显示声明变量类型，如：\n```kotlin\nval a: Int = 10\n```\nJava和Kotlin数据类型对照表：\n| Java基本数据类型 | Kotlin对象数据类型 | 数据类型说明 |\n| :------------: | :----------------: | :---------: |\n| int | Int | 整型 |\n| long | Long | 长整型 |\n| short | Short | 短整型 |\n| float | Float | 单精度浮点型 |\n| double | Double | 双精度浮点型 |\n| boolean | Boolean | 布尔型 |\n| char | Char | 字符型 |\n| byte | Byte | 字节型 |\n\n### 变量延迟初始化\n`lateinit`可以告诉`Kotlin`编译器我会晚些时候对其进行初始化，避免一开始声明变量时需赋值为空，示例如下：\n```kotlin\nclass Class1 {\n    private lateinit var params: Params\n    fun doSomthing(){\n        if(!::params.isInitialized){\n        params = Params(...)\n        }\n    }\n}\n```\n为了避免因变量没有初始化导致程序崩溃，故通过，`::params.isInitialized`来判断变量是否已经初始化\n\n## 2、函数\n自定义函数，语法规则如下：\n```kotlin\nfun methodName(param1:Int, param2:Int):Int{\n    return 0\n}\n//Kotlin函数语法糖,当函数只有一行代码时，可省去return关键字，等号可表示返回值的意思\nfun methodName(param1:Int, param2:Int):Int = 0\n```\n\n## 3、if 条件语句\n`Kotlin` 中的 `if`  语句相比于 Java 有一个额外功能，它可以有返回值  \n`if` 语句中每一个条件中最后一行代码可作为返回值，如下：\n```kotlin\nfun methodName(param1:Int, param2:Int):Int{\n    return if(param1 > param2){\n        param1\n    } else{\n        param2\n    }\n}\n//Kotlin语法糖..简化为\nfun methodName(param1:Int, param2:Int):Int = if (param1 > param2) param1 else param2\n```\n\n## 4、when 条件语句\n`when`语句允许掺入一个任意类型的参数，然后可以在`when`的结构体中定义一系列条件。\n格式为：  \n```\n匹配值 -> {执行逻辑}\n```\n示例，不同学生对应不同分数：\n```kotlin\nfun getScore(name:String) = when(name){\n    \"Tom\" -> 60\n    \"Jim\" -> 30\n    \"Tommy\" -> 50\n    \"Lily\" -> 70\n    else -> 0\n}\n//当执行逻辑里只有一行代码时可省去{}，且when语句也将最后一行作为返回值\n```\n`when` 不带参数的用法，示例：\n```kotlin\nfun getScore(name:String) = when{\n    name == \"Tom\" -> 60\n    name == \"Jim\" -> 30\n    name == \"Tommy\" -> 50\n    name == \"Lily\" -> 70\n//    name.startWith(\"Tom\") -> 80 //将以Tom开头的名字，分数都为80\n    else -> 0\n}\n```\nwhen语句也可用作类型匹配，示例：\n```kotlin\nfun checkNumber(num:Number){\n    when(num){\n        is Int -> println(\"Number is Int\")\n        is Double -> println(\"Number is Bouble\")\n        ....\n        else -> (\"Number not support\")\n    }\n}\n```\n\n## 5、循环语句\n### 区间\nKotlin中创建一个区间：  \n双端闭区间，如下：\n```kotlin\nval range = 0..10\n//表示创建了一个从0到10 的区间，并且两端都是闭区间，数学式为[0,10]\n//其中 .. 是创建双端闭区间的关键字\n```\n单端闭区间，如下：\n```kotlin\nval range = 0 until 10\n//表示创建了一个 从0到10的左闭右开区间，数学式为[1,10)\n//其中 until 是创建单端闭区间的关键字\n```\n注意：使用 `..` 和 `until` 关键字都要求左端小于等于右端\n\n降序区间，如下：\n```kotlin\nval range = 10 downTo 1\n//表示创建了一个从10到1的区间，数学式表示为[10,1]\n//downTo是创建降序区间的关键字\n```\n\n### for-in 循环\n示例如下：\n```kotlin\nfor (i in 0..10){\n    ....\n}\n//表示遍历这个从0到10的闭区间\n```\n由于 `for-in` 循环每次执行循环时区间范围递增 1，所以可使用 `step` 关键字来跳过一些元素\n示例如下：\n```kotlin\nfor (i in 0..10 step 2){\n    ....\n}\n//表示每次执行循环递增2\n```\n\n## 6、面向对象\n### 类与对象\nKotlin中创建一个对象，如下：\n```kotlin\nclass ClassName{\n}\n```\n对这个类进行实例化，如下：\n```kotlin\nval c = ClassName()\n```\n\n### 类与构造对象\n在Kotlin中任何一个非抽象类默认都是不可被继承的  \n使类可以被继承，如下：\n```kotlin\nopen class ClassName{\n}\n//加上open关键字使类可被继承\n```\n让一个类去继承另一个类，如下：\n```kotlin\nclass class1 : class2(){\n}\n```\n\nKotlin中的构造函数分为**主构造函数**和**次构造函数**  \n每一个类默认都会有一个不带参数的主构造函数，可显式地指定参数。 \n\n主构造函数特点没有函数体，直接定义在类名后面即可，如下：\n```kotlin\nclass class1(val params1:String, val params2:Int){\n}\n```\n实例化，如下：\n```kotlin\nval c = class1(\"Hello\",10)\n```\n\n当需要在主构造函数中编写一些逻辑时，  \nKotlin提供了一个 `init` 结构体，可将主构造函数逻辑写在里面，如下：\n```kotlin\nclass class1(val params1:String, val params2:Int){\n    init{\n        prinln(params1 + params2)\n    }\n}\n```\n\n子类的构造函数必须调用父类中的构造函数，如下：\n```kotlin\n//父类\nopen class Class2(val name:String, val age:Int){\n}\n//子类\nclass Class1(val son:String, val grade:Int, name:String, age:Int) : \n        Class2(name, age){\n}\n//创建实例\nval c = Class1(\"a123\",2,\"Tom\",12)\n```\n注意，在`Class1`类中不能将`name`和`age`声明成`val`，因为在主构造函数中声明成`var`或`val`的参数将自动成为该类的字段。不加任何关键字，让它的作用域仅限定在主构造函数当中即可。\n\n次构造函数  \nKotlin规定，当一个类既有主构造函数也有次构造函数时，**所有的次构造函数都必须调用主构造函数**(包括间接调用)，示例如下：\n```kotlin\nclass Class1(val son:String, val grade:Int, name:String, age:Int):\n        Class2(name, age){\n    constructor(name:String,age:Int) : this(\"\",0,name,age){\n    }\n    constructor():this(\"\",0){\n    }\n}\n//分别调用构造函数进行实例化\nval c1 = Class1()\nval c2 = Class1(\"Tom\",19)\nval c3 = Class1(\"a123\",4,\"Tom\",19)\n```\n次构造函数通过`constructor`关键字来定义，这里定义的两个次构造函数。第一个接收的参数时`name`和`age`参数，又通过`this`关键字调用了主构造函数，并将`son`和`grade`这两个参数赋值为初始值；第二个个次构造函数不接收任何参数，通过`thsi`关键字调用了第一个次构造函数，并将参数赋值为初始值。第二个次构造函数间接调用了主构造函数，所以也是合法的.\n\n### 接口\nKotlin中让一个类实现一个接口以及实现接口中的方法，如下：\n```kotlin\nclass Class1() : Class2() , InterfaceName{\n    override fun doSomething(){\n    }\n}\n```\n实现接口使用逗号隔开，使用`override`关键字来重写父类或者接口中的函数\n\nKotlin中允许对接口中定义的函数进行默认实现，示例如下：\n```kotlin\ninterface InterfaceName{\n    fun doSomething(){\n        .....//执行逻辑\n    }\n}\n```\n如果接口中的函数有了函数体，这个函数体中的内容就是它的默认实现，一个类去实现该接口时，**会强制要求实现没有函数体的函数，不会强制要求实现有函数体的函数，不实现时就会自动使用默认的实现逻辑。**\n\n### 修饰符\nJava 和 Kotlin 函数可见性修饰符对照表\n| 修饰符 | Java | Kotlin |\n| :---: | :---: | :---: |\n| public | 所有类可见 | 所有类可见（默认）|\n| private | 当前类可见 | 当前类可见 |\n| protected | 当前类、子类、同一包路径下的类可见 | 当前类、子类可见 |\n| default | 同一包路径下的类可见（默认） | 无 |\n| internal | 无 | 同一模块中的类可见 |\n\n### 数据类与单例类\n数据类用于将服务器端或数据库中的数据映射到内存中，为编程逻辑提供数据模型的支持。  \nKotlin中创建数据类，示例如下：\n```kotlin\ndata class Cellphone(val brand:String, val price:Double)\n//使用上面这个数据类，如下\nfun main() {\n    val cellphone1 = Cellphone(\"Samsung\", \"1299.99\")\n    val cellphone2 = Cellphone(\"Samsung\", \"1299.99\")\n    println(cellphone1)\n    println(\"cellphone1 equals cellphone2\"+(cellphone1 == cellphone2))\n}\n//运行结果为\n//Cellphone(brand=Samsung, price=1299.99)\n//cellphone1 equals cellphone2 true\n```\n当在一个类前面声明`data`关键字时，便表明你希望这个类是一个数据类  \n当一个类中没有任何代码时，可以将大括号省略。\n\n单例类  \n用于保证某个类在全局最多只能拥有一个实例，不同于Java中实现单例模式的方式，在 Kotlin 中实现非常简单。  \nKotlin中创建单例类，创建类型选择“Object”，示例代码如下：\n```kotlin\nobject Singleton{\n    fun singletonTest(){\n        println(\"SingeltonTest is called\")\n    }\n}\n//调用单例类中的函数\nSingleton.singletonTest()\n```\n\n更多文章：  \n[Kotlin学习知识点整理-基础篇-01](https://juejin.im/post/6891231633702125576)  \n[Kotlin学习知识点整理-基础篇-02](https://juejin.im/post/6891260438219227143)  \n[Kotlin学习知识点整理-基础篇-03](https://juejin.im/post/6891621855204786184)  \n[Kotlin学习知识点整理-进阶篇-04](https://juejin.im/post/6892393981695819789)\n>写在最后：遨游在知识的海洋，永远对技术怀有一个敬畏之心\n"},{"title":"Hello World","url":"/2021/03/06/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]