[{"title":"Kotlin学习-进阶篇-05","url":"/2021/03/04/Kotlin学习-进阶篇-05/","content":"![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16bc39bfcece47bd96edee5511fb1ca8~tplv-k3u1fbpfcp-watermark.image)\n# Kotlin知识点整理进阶\n>本文是我在学习Kotlin的过程中整理的一些知识点，如有错误，欢迎指正\n## 一、运算符重载\n运算符重载使用的是 `operator` 关键字  \n以加号运算符为例，实现让两个对象相加的功能，语法结构如下：\n```kotlin\nclass OBj{\n    operator fun plus(obj: Obj): Obj{\n     //处理相加逻辑\n    } \n}\n//调用方法如下\nval obj1 = Obj()\nval obj2 = Obj()\nval obj3 = obj1 + obj2 \n```\n<table width=\"400\">\n    <caption>语法糖表达式和实际调用函数对照表</caption>\n    <tr>\n        <th>语法糖表达式</th>\n        <th>实际调用函数</th>\n    </tr>\n    <tr>\n        <td align=\"center\">a + b</td>\n        <td align=\"center\">a.plus(b)</td>\n    </tr>\n    <tr>\n        <td align=\"center\">a - b</td>\n        <td align=\"center\">a.minus(b)</td>\n    </tr>\n    <tr>\n        <td align=\"center\">a * b</td>\n        <td align=\"center\">a.times(b)</td>\n    </tr>\n    <tr>\n        <td align=\"center\">a / b</td>\n        <td align=\"center\">a.div(b)</td>\n    </tr>\n    <tr>\n        <td align=\"center\">a % b</td>\n        <td align=\"center\">a.rem(b)</td>\n    </tr>\n    <tr>\n        <td align=\"center\">a++</td>\n        <td align=\"center\">a.inc()</td>\n    </tr>\n    <tr>\n        <td align=\"center\">a--</td>\n        <td align=\"center\">a.dec()</td>\n    </tr>\n    <tr>\n        <td align=\"center\">+a</td>\n        <td align=\"center\">a.unaryPlus()</td>\n    </tr>\n    <tr>\n        <td align=\"center\">- a</td>\n        <td align=\"center\">a.unaryMinus()</td>\n    </tr>\n    <tr>\n        <td align=\"center\">! a</td>\n        <td align=\"center\">a.not()</td>\n    </tr>\n    <tr>\n        <td align=\"center\">a == b</td>\n        <td align=\"center\">a.equals(b)</td>\n    </tr>\n    <tr>\n        <td align=\"center\">a > b </td>\n        <td align=\"center\" rowspan=\"4\">a.compareTo(b)</td>\n    </tr>\n    <tr>\n        <td align=\"center\">a < b</td>\n    </tr>\n    <tr>\n        <td align=\"center\">a >= b</td>\n    </tr>\n    <tr>\n        <td align=\"center\">a <= b</td>\n    </tr>\n    <tr>\n        <td align=\"center\">a..b</td>\n        <td align=\"center\">a.rangeTo(b)</td>\n    </tr>\n    <tr>\n        <td align=\"center\">a[b]</td>\n        <td align=\"center\">a.get(b)</td>\n    </tr>\n    <tr>\n        <td align=\"center\">a[b] = c</td>\n        <td align=\"center\">a.set(b, c)</td>\n    </tr>\n    <tr>\n        <td align=\"center\">a in b</td>\n        <td align=\"center\">b.contains(a)</td>\n    </tr>\n</table>\n\n注：最后一个 `a in b`,表示判断 `a` 是否在 `b` 中，而 `b.contains(a)` 表示判断 `b` 是否包含 `a`，因此这两种表达方式是等价的。\n\n## 二、扩展函数 + 运算符重载使用示例\n下面来看个示例，现在准备用扩展函数+运算符重载来实现一个让字符串重复打印指定次数的功能，类似 `str * n`这种形式，代码如下：  \n```kotlin\noperator fun String.tines(n : Int) : String {\n    val builder = StringBuilder()\n    repeat(n) {\n        builder.append(this)\n    }\n    return builder.toString\n}\n```\n`operator`关键字是必不可少的，接着参考上面的表可知函数名是 `tines`，然后由于我们是给字符串添加的扩展函数，故在方法名前面加上了 `String` ，最后借助 `repeat()` 将字符串重复 `n` 次。  \n\n现在，字符串就有了可以和数字相乘的能力，比如执行如下代码：\n```kotlin\nval str = \"abc\" * 3\nprintln(str)\n\n//最终打印结果就是：abcabcabc\n```\n其实 `Kotlin` 中的 `String` 类中已经提供了一个 `repeat()` 函数，所以我们还可以简化上面的函数，如下：\n```kotlin\noperator fun String.tines(n : Int) = repeat(n)\n```\n\n\n## 三、高阶函数\n### 1、定义高阶函数\n定义：如果一个函数接收另一个函数作为参数，或者返回值的类型是另一个函数，那么该函数就称为高阶函数。  \n\n定义一个函数类型：\n```kotlin\n(String, Int) -> Unit\n```\n`->` 左边的部分就是用来声明该函数接收什么参数的，多个参数之间使用逗号隔开，如果不接受任何参数，写一对空括号就可以。  \n`->` 右边的部分用于声明该函数的返回值是什么类型，如果没有返回值就使用 Unit，它大致相当于Java中的 void  \n\n定义一个高阶函数：\n```kotlin\nfun example(func: (String, Int) -> Unit){\n    func(\"hello\",123)\n}\n```\n用途：高阶函数允许让函数类型的参数来决定函数的执行逻辑。即使是用一个高阶函数，只要传入不同的函数类型参数，那么它的执行逻辑和最终的返回结果就可能是完全不同的。  \n我们来看一个示例：\n```kotlin\nfun StringBuilder.build(block: StringBuilder.() -> Unit): StringBuilder{\n    block()\n    return this\n} \n```\n我们给 `StringBuilder` 定义了一个扩展函数 `build` ，它接收一个函数类参数。并且如果在函数类型前面加上了 `ClassName.` 的语法结构，就表示这个函数类型是定义在哪个类中的。故这里的参数加上了 `StringBuilder.` 的语法结构，就表示这个函数类型是定义在 `StringBuilder` 这个类中的，这样的作用是当我们调用 `build` 函数时传入的 `Lambda` 表达式可以自动拥有 `StringBuilder` 的上下文，类似于 `apply` 函数，不用的地方在于 `apply` 可以作用到所有类上，这里的只能作用在 `StringBuilder` 类上。  \n用法如下：\n```kotlin\nval result = StringBuilder.build{\n    append(\"Start here \\n\")\n    append(\"str1 str2 \\n\")\n    append(\"End here\")\n}\n```\n\n### 2、内联函数\n内联函数主要是为了解决运行Lambda表达式时带来的运行时开销。  \n内联函数用法 在定义高阶函数时加上 `inline` 关键字，如下所示：\n```kotlin\ninline fun num1AndNum2(num1:Int,num2:Int,operation: (Int,Int) -> Int) : Int{\n    val result = operation(num1, num2)\n    return result\n}\n```\n`noinline` 只想内联其中一个Lambda表达式：\n```kotlin\ninline fun num1AndNum2(block1 : () -> Unit, noinline block2 : () -> Unit){\n}\n```\nQ：为何Kotlin要提供一个 `noinline` 关键字来排除内联功能？  \nA：内联函数的函数类型参数在编译时会进行代码替换，因此它没有真正的参数属性。非内联的函数类型参数可以自由地传递给其它任何函数，因为它就是一个真实的参数，而内联的函数类型参数只允许传递给另一个内联函数。  \n（补充：内联函数与非内联函数还有一个重要的区别：内联函数所引用的Lambda表达式中是可以使用 return 关键字来进行函数返回的，而非内联函数只能局部返回）  \n\n上一篇 [Kotlin学习知识点整理-进阶篇-04](https://juejin.cn/post/6892393981695819789)\n","tags":["kotlin","笔记","阅读"],"categories":["Kotlin"]},{"title":"Jetpack 架构组件，带你快速上手","url":"/2020/11/18/Jetpack 架构组件，带你快速上手/","content":"![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93847c64524e486f929351c2dd8bb87f~tplv-k3u1fbpfcp-watermark.image)\n# Jetpack\n>本文是我在学习Jetpack的过程中做的一些记录，如有错误，欢迎指正  \n>本文包含了 ViewModel、Lifecycles、LiveData、Room、WorkManager 的相关用法，你可以通过目录直接跳转到你想了解的地方\n# ViewModel\n简单介绍下 `ViewModel`：`ViewModel` 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel 类让数据可在发生屏幕旋转等配置更改后继续留存。  \n这是官网给出的介绍，简单解释一下 `ViewModel` 就是将界面 (Activity或Fragment) 中显示的数据从其中分离出来，单独进行处理，减少界面的逻辑复杂程度，减轻界面的负担。  \n\n## 接下来简单使用一下：  \n添加依赖：\n```gradle\nimplementation 'androidx.lifecycle:lifecycle-extensions:2.2.0'\n```\n给对应的 `Activity` 创建一个对应的 `XXXViewModel` 类，并让它继承自 `ViewModel` （不管是 `Activity` 还是 `Fragment` 都最好给每一个都创建一个对应的 `ViewModel` ）\n```kotlin\nclass MainViewModel : ViewModel(){\n    var counter = 0 //用于计数\n}\n```\n\n在 Activity 中使用：\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    lateinit var viewModel: MainViewModel\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        viewModel = ViewModelProvider(this).get(viewModel::class.java)\n        btn_plus.setOnClickListener{\n            viewModel.counter++\n        }\n        refreshCounter()\n    }\n\n    private fun refreshCounter() {\n        tv_info.text = viewModel.counter.toString()\n    }\n}\n```\n现在我们实现了一个计数器，在这里需要注意，我们不能直接去创建 `ViewModel` 的实例，而是要通过 `ViewModelProvider` 来获取 `ViewModel` 的实例，之所以这样是因为 `ViewModel` 有独立的生命周期，且其生命周期长于 `Activity` 的生命周期，如果在 `onCreat()` 中创建 `ViewModel` 的实例，那么每次 `onCreat()` 执行时，`ViewModel` 都会创建一个实例，这样就无法保存其中的数据了。  \n\n`ViewModel` 对象存在的时间范围是获取 `ViewModel` 时传递给 `ViewModelProvider` 的 `Lifecycle`。`ViewModel` 将一直留在内存中，直到限定其存在时间范围的 `Lifecycle` 永久消失，如下图是 `Activity` 的生命周期和 `VIewModle` 的生命周期对应的情况\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5619d7bcc394e1faf99efef9a746d28~tplv-k3u1fbpfcp-watermark.image)\n\n## 向 ViewModel 传递参数\n借助 `ViewModelProvider.Factory` ，下面我们来实现退出程序后再打开，数据仍然不会消失的效果\n先修改 `MainViewModel` 的代码，如下：\n```kotlin\nclass MainViewModel(counterReserved: Int) : ViewModel(){\n    var counter = counterReserved //用于计数\n}\n```\n\n接着创建 `MainViewModelFactory` 类，并实现 `ViewModelProvider.Factory` 接口，如下：\n```kotlin\nclass MainViewModelFactory(private val countReserved: Int) : ViewModelProvider.Factory {\n    override fun <T : ViewModel?> create(modelClass: Class<T>): T {\n        return MainViewModel(countReserved) as T\n    }\n}\n```\n我们这里实现了接口要求我们的 `create` 方法，在方法里面我们创建并返回了一个 `MainViewModel` 的实例，为什么我们这里就可以创建 `MainViewModel` 的实例了呢？因为 `create()` 方法的执行时机和 `Activity` 的生命周期无关，所以不会产生之前提到的问题。\n\n最后修改 activity 中的代码，如下：\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    lateinit var viewModel: MainViewModel\n    lateinit var sp: SharedPreferences\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        sp = getSharedPreferences(\"count_reserved\",Context.MODE_PRIVATE)\n        val countReserved = sp.getInt(\"count_reserved\",0)\n        viewModel = ViewModelProvider(this,MainViewModelFactory(countReserved))\n            .get(viewModel::class.java)\n        ......\n        btn_clear.setOnClickListener {\n            viewModel.counter = 0\n            refreshCounter()\n        }\n        refreshCounter()\n    }\n\n    override fun onPause() {\n        super.onPause()\n        val edit = sp.edit()\n        edit.putInt(\"count_reserved\",viewModel.counter)\n        edit.apply()\n    }\n    ......\n}\n```\n\n# Lifecycles\n顾名思义，`Lifecycles` 是一个用来感知 `Activity` 生命周期的组件，下面来学习下简单用法。\n## 简单使用：\n新建一个 `MyObserver` 类，并实现 `LifecycleObserver` 接口\n```kotlin\nclass MyObserver : LifecycleObserver{\n}\n```\n`LifecycleObserver` 这是一个空方法接口，我们可以在 `MyObserver` 中定义任何方法，如果需要感知 `Activity` 的生命周期就需要为方法添加注解，如下所示：\n```kotlin\nclass MyObserver : LifecycleObserver{\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_START)\n    fun activityStart() {\n        Log.d(\"MyObserver\",\"activityStart\")\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)\n    fun activityStop() {\n        Log.d(\"MyObserver\",\"activityStop\")\n    }\n}\n```\n这里使用 `@OnLifecycleEvent` 注解，并传入了一种生命周期事件，生命周期事件一共有 7 种，分别是：`ON_CREATE` 、`ON_START` 、`ON_RESUME` 、`ON_PAUSE` 、`ON_STOP` 、`ON_DESTROY` 、`ON_ANY` 。前六种分别匹配 `Activity` 中相应的的生命周期回调，最后一种表示可以匹配 `Activity` 的任何生命周期回调。\n\n接下来就是需要 `LifecycleOwner` 去通知 `MyObserver` 生命周期发生了变化，它可以使用如下的语法结构去通知 `MyObserver`\n```kotlin \nlifecycleOwner.lifecycle.addObserver(MyObserver())\n```\n这里 `LifecycleOwner` 调用了 `getLifecycle` 方法，得到一个 `Lifecycle` 对象，接着调用 `addObserver` 来观察 `LifecycleOwner` 的生命周期，再把 `MyObserver` 传进去。  \n\n`LifecycleOwner` 是个什么？如何让获取一个 `LifecycleOwner` 的实例？  \n大多数情况下，只要 `Activity` 是继承自 `AppCompatActivity` 的，或者 `Fragment` 是继承自 `androidx.fragment.app.Fragment` 的，那么它们本身就是一个 `LifecycleOwner` 的实例，所以我们在 `Activity` 中就可以这样写\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    ......\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        ......\n        lifecycle.addObserver(MyObserver())\n    }\n    ......\n}\n```\n现在程序可以感知到 `Activity` 的生命周期变化，但没法主动获知当前的生命周期状态，解决这个问题，只需要在 `MyObserver` 的构造函数中将 `Lifecycle` 对象传进去即可，如下：\n```kotlin\nclass MyObserver(val lifecycle: Lifecycle) : LifecycleObserver{......}\n```\n有了 `Lifecycle` 对象后，就可以在任何地方调用 `lifecycle.currntState` 来主动获取当前的生命周期状态。  \n`lifecycle.currntState` 返回的生命周期状态时一个枚举类型，一共有 5 种状态类型，如下：\n```\nINITIALIZED\nDESTROYED\nCREATED\nSTARTED\nRESUMED\n```\n它们与 `Activity` 的生命周期回调所对应的关系如图：\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1664e9bd88f2492dba7ab10f7be9316f~tplv-k3u1fbpfcp-watermark.image)\n\n# LiveData\n`LiveData` 是一种可观察的数据存储器类。与常规的可观察类不同，`LiveData` 具有生命周期感知能力，意指它遵循其他应用组件（如 `Activity`、`Fragment` 或 `Service`）的生命周期。这种感知能力可确保 `LiveData` 仅更新处于活跃生命周期状态的应用组件观察者。\n## 简单使用\n`LiveData` 可以包含任何类型的数据，并在数据发生变法的时候通知给观察者  \n\n修改 `MainViewModel` 中的代码，如下：\n```kotlin\nclass MainViewModel(countReserved: Int) : ViewModel() {\n    var counter = MutableLiveData<Int>()\n    init {\n        counter.value = countReserved\n    }\n\n    fun plusOne() {\n        val count = counter.value ?: 0\n        counter.value = count + 1\n    }\n    fun clear() {\n        counter.value = 0\n    }\n}\n```\n这里将 `counter` 变量修改成了一个 `MutableLiveData` 对象，这是一种可变的 `LiveData` 。它主要有三种读写数据的方法，分别是：  \n* `getvalue()` //用于获取 `LiveData` 中包含的数据\n* `setValue()` //用于给 `LiveData` 设置数据，但是只能在主线程中调用\n* `postValue()` //用于在非主线程中给 `LiveData` 设置数据\n\n下面来修改 MainActivity 中的代码：\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    ......\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        ......\n        btn_plus.setOnClickListener{\n            viewModel.plusOne()\n        }\n        btn_clear.setOnClickListener {\n            viewModel.clear()\n        }\n\n        viewModel.counter.observe(this, Observer { count ->\n            tv_info.text = count.toString()\n        })\n    }\n\n    override fun onPause() {\n        super.onPause()\n        val edit = sp.edit()\n        edit.putInt(\"count_reserved\",viewModel.counter.value ?: 0)\n        edit.apply()\n    }\n}\n```\n这里 `counter` 变量已经变成了一个 `LiveData` 对象，任何 `LiveData` 对象都可以调用它的 `observe()` 方法来观察数据的变化。`observer()` 方法接收两个参数：第一个参数是一个 `LifecycleOwner` 对象，这里也就是 `Activity` 自己。第二个参数是一个 `Observer` 接口，当 `counter` 中包含的数据发生变化时，就会回调到这里。  \n\n关于 `observe()` 方法，Google 官方在专门面向 Kotlin 语言的 API 中提供了很多好用的语法扩展，要使用它需添加依赖：\n```gradle\nimplementation 'androidx.lifecycle:lifecycle-livedata-ktv:2.2.0'\n```\n之后我们就可以使用如下结构的 `observe()` 方法了\n```kotlin\nviewModel.counter.observe(this) { count -> \n    tv_info.text = count.toString()\n}\n```\n以上是 `LiveData` 基本用法，可以正常使用，但仍然不是最规范的用法， 主要问题是我们将 `counter` 这个可变的 `LiveData` 暴露给了外部，这样在 `ViewModel` 外面也是可以给 `counter` 设置数据，从而破坏了 `LiveData` 数据的封装性  \n\n比较推荐的做法是，永远只暴露不可变的 `LiveData` 给外部，下面来改造下 `MainViewModel` ，如下：\n```kotlin\nclass MainViewModel(countReserved: Int) : ViewModel() {\n    \n    val counter : LiveData<Int>\n        get() =_counter\n    private val _counter = MutableLiveData<Int>()\n    \n    init {\n        _counter.value = countReserved\n    }\n    fun plusOne() {\n        val count = _counter.value ?: 0\n        _counter.value = count + 1\n    }\n    fun clear() {\n        _counter.value = 0\n    }\n}\n```\n这里 `_counter` 变量对于外部便是不可见的，而我们又定义了一个 `counter` 变量，类型声明为不可变的 `LiveData` ，并在它的 `get()` 属性方法中返回 `_counter` 变量。  \n这样当外界调用 `counter` 变量时，实际上获得的是 `_counter` 的实例，但是无法给 `counter` 设置数据，从而保证了 `LiveData` 数据的封装性  \n\n## LiveData 中的 map 和 switchMap\n`LiveData` 为了能够应对各种不同需求场景，提供了两种转换方法：`map()` 和 `switchMap()` 方法\n\n### map() \n这个方法的作用是将实际包含数据的 `LiveData` 和仅用于观察数据的 `LiveData` 进行转换，实例如下：  \n比如有一个 `User` 类，其中包含用户的姓名、年龄，如下：\n```kotlin\ndata class User(var firstName: String,var lastName:String, var age: Int) {}\n```\n这里包含了三个数据，但如果我们的 `Activity` 明确了只需要用户的姓名，不关心年龄时 还将整个 `User` 暴露出去就不太合适，这时候就可以使用 `map()` 方法，将 `User` 类型的 `LiveData` 自由的转型成任意其他类型的 `LiveData`，如下：\n```kotlin\nclass MainViewModel(countReserved: Int) : ViewModel() {\n    private val userLiveData = MutableLiveData<User>()\n\n    val userName : LiveData<String> = Transformations.map(userLiveData){ user ->\n        \"${user.firstName} ${user.lastName}\"\n    }\n......\n}\n```\n`map()` 方法接收两个参数：\n* 第一个：参数是原始的 `LiveData` 对象；\n* 第二个：参数是一个转换函数\n\n我们就只需要在转换函数里写具体的逻辑即可  \n另外，我们将 `userLiveData` 声明成了 `private` ，以保证数据的封装性，外部只需要观察 `userName` 就可以了，当 `userLiveData` 数据发生变化时，`map()` 方法会监听到变化并执行转换函数中的逻辑，然后将转换之后的数据通知给 `userName` 的观察者\n\n### switchMap()\n我们通过一个实例来学习。根据传入的 `userId` 参数去服务器请求或者到是数据库中查找相应的 `User` 对象，但是这里只是模拟示例，因此每次传入的 `userId` 当作用户姓名来创建一个新的 `User` 对象即可  \n\n代码如下，先创建一个 `Repository` 单例类，模拟获取用户数据的功能：\n```kotlin\nobject Repository {\n    fun getUser(userId: String) : LiveData<User>{\n        val liveData = MutableLiveData<User>()\n        liveData.value = User(userId,userId,0)\n        return liveData\n    }\n}\n```\n\n下面获取 `Repository` 的 `LiveData` 对象，\n```kotlin\nclass MainViewModel(countReserved: Int) : Int{\n    ...\n    fun getUser(userId: String) : LiveData<User> {\n        return Repository.getUser(userId)\n    }\n}\n```\n在 `Activity` 中观察 `LiveData`\n```kotlin\nviewModel.getUser(userId).observe(this) { -> \n}\n```\n以上的这种呢做法完全错误，因为每次调用 `getUser()` 方法返回的都是一个新的 `LiveData` 实例，而上述写法会一直观察老的 `LiveData` 实例，这种情况下，`LiveData` 是不可能观察的   \n\n以下是正确做法，  \n借助 `switchMap` ，它的使用场景比较固定：如果 `VIewModel` 中的某个 `LiveData` 对象是调用另外的方法获取的，那么就可以借助 `switchMap()` 方法，将这里 `LiveData` 对象转换成另外一个可观察的 `LiveData` 对象。修改 `MainViewModel` 中的代码，如下：\n```kotlin\nclass MainViewModel(countReserved: Int) : ViewModel() {\n    ....\n    private val userIdLiveData = MutableLiveData<String>()\n\n    val user: LiveData<User> = Transformations.switchMap(userIdLiveData) { userId ->\n        Repository.getUser(userId)\n    }\n    fun getUser(userId: String) {\n        userIdLiveData.value = userId\n    }\n}\n```\n`switchMap()` 方法接收两个参数：  \n* 第一个：传入新增的 `userIdLiveData` ，`switchMap()` 方法会对它进行观察\n* 第二个：是一个转换函数，我们必须在这个转换函数中返回一个 `LiveData` 对象，因为 `switchMap()` 方法的工作原理就是要将转换函数中返回的 `LiveData` 对象转换成另一个可观察的 `LiveData` 对象。\n\n现在 `user` 对象就是一个可观察的 `LiveData` 对象了  \n修改 `Activity` 中的代码，如下：\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    ....\n    override fun onCreate(savedInstanceState: Bundle?) {\n        ....\n        btn_getUser.setOnClickListener {\n            val userId = (0..1000).random().toString()\n            viewModel.getUser(userId)\n        }\n        viewModel.user.observe(this,{\n        tv_info.text = it.firstName\n        })\n    }\n}\n```\n现在已经实现了功能并且可以正常运行了。\n\n当我们的 `ViewModel` 中某个获取数据的方法有可能是没有参数的，这个时候该怎么办呢？  \n这里我们先创建一个空的 `LiveData` 对象：\n```kotlin\nclass MyViewModel : ViewModel(){\n    \n    private val refreshLiveData = MutableLiveData<Any?>()\n    \n    val refreshResult = Transformatinos.switchMap(refreshLiveData) {\n        Repository.refresh()\n    }\n    \n    fun refresh() {\n        refreshLiveData.value = refreshLiveData.value\n    }\n}\n```\n在 `refresh()` 方法中，只是将 `refreshLiveData` 原有的数据取出来（默认是空），再重新设置到 `refreshResult` 当中，这样就能触发一次数据变化。  \n在 `LiveData` 内部不会判断即将设置的数据和原有数据是否相同，只要调用了 `setValue()` 或 `postValue()` 方法，就一定会触发数据变化事件，然后我们只需要在 `Activity` 中观察 `refreshResult` 这个 `LiveData` 对象即可\n\n# Room\n`Room` 是 Google 官方推出的一个 `ORM`（`Object Relational Mapping` 对象关系映射）框架，并将它加入了 `Jetpack` 中。\n\n`Room` 的整体结构主要由 `Entity`、`Dao`、`Database` 这三个部分组成，每个部分都有自己明确的职责：\n* `Entity`：用于定义封装实际数据的实体类，每个实体类都会在数据库中都有一张对应的表，并且表中的列是根据实体类中的字段自动生成的。\n* `Dao`：`Dao` 是数据访问的意思，同长会在这里对数据库的各项操作进行封装。在实际编程中，逻辑层就不用和底层数据打交道了，直接和 `Dao` 层进行交互就可。\n* `Database`：用于定义数据库中的关键信息，包括数据库的版本号、包含哪些实体类以及提供 `Dao` 层的访问实例。\n\n## Room 的具体用法 \n添加依赖：\n```gradle\n....\napply plugin: 'kotlin-kapt'\n\ndependencies{\n    ....\n    implementation 'androidx.room:room-runtime:2.2.5'\n    kapt 'androidx.room:room-compiler:2.2.5'\n}\n```\n`kapt` 只能在 `Kotlin` 项目中使用，如果是 `Java` 项目的话，使用 `amotationProcessor` 即可\n\n接下来按照刚才介绍的 `Room` 的三个部分来一一进行实现\n\n### 定义 Entity：\n我们直接就使用 上文定义的 User 类来改造\n```kotlin\n@Entity\ndata class User(var firstName: String,var lastName:String, var age: Int) {\n\n    @PrimaryKey(autoGenerate = true) \n    var id: Long = 0  //给每个实体类都添加一个字段，并设为主键\n}\n```\n`@Entity` 注解：将 `User` 声明成了一个实体类  \n`@PrimaryKey` 注解：将 `id` 字段设为主键，将 `autoGenerate` 设置为 `true` ，使得主键的值自动生成\n\n### 定义 Dao：\n这一部分比较关键，因为所有访问数据库的操作都是在这里封装  \n新建一个 UserDao 接口，如下：\n```kotlin\n@Dao\ninterface UserDao {\n    \n    @Insert\n    fun insetUser(user: User) : Long\n    \n    @Update\n    fun updateUser(newUser: User)\n    \n    @Query(\"select * from User\")\n    fun loadAllUser() : List<User>\n    \n    @Query(\"select * from User where age > :age\")\n    fun loadUsersOlderThan(age: Int) : List<User>\n    \n    @Delete\n    fun deleteUser(user: User)\n    \n    @Query(\"delete from User where lastName = :lastName\")\n    fun deleteUserByLastName(lastName: String) : Int\n}\n```\n`@Dao` 注解：让 `Room` 能够识别到 `UserDao` 是一个 `Dao`  \n`@Insert` 注解：表示将参数传入 `User` 对象插入数据库中，插入完成后还会返回自动生成的主键 `id` 值  \n`@Update` 注解：表示会将参数中传入的 `User` 对象更新到数据库当中  \n`@Delete` 注解：表示会将参数传入的 `User` 对象从数据库中删除  \n以上几种数据库操作都直接使用注解表示即可，不用编写 `SQL` 语句。如果想要从数据库中查询数据，或者使用非实体类参数来增删改查数据，就必须编写 `SQL` 语句，比如刚刚定义的 `loadAllUsers()` 方法，用于从数据库中查询所有用户。\n\n`@Query` 注解：该注解中必须编写 `SQL` 语句，可以将方法中传入的参数指定到 `SQL` 语句当中，比如 `loadUserOlderThan()` 方法就可以查询所有年龄大于指定参数的用户。 \n\n如果是使用非实体类参数来增删改查数据，也要编写 `SQL` 语句才行，而且只能使用 `@Query` 注解，比如 `deleteUserByLastName()` 方法\n\n### 定义 Database\n这部分一般只需要定义三个部分：数据库版本号、包含哪些实体类、提供 `Dao` 层的访问实例。  \n新建一个 `AppDatabase.kt` 文件，如下：\n```kotlin\n@Database(version = 1, entities = [User::class])\nabstract class AppDatabase : RoomDatabase() {\n\n    abstract fun userDao() : UserDao\n    companion object{\n        private var instance: AppDatabase? = null\n\n        @Synchronized\n        fun getDatabase(context: Context): AppDatabase {\n            instance?.let {\n                return it\n            }\n            return Room.databaseBuilder(context.applicationContext,\n                AppDatabase::class.java, \"app_database\")\n                .build().apply {\n                    instance = this\n                }\n        }\n    }\n}\n```\n`@Database` 注解：其中声明了数据库版本号以及包含的实体类，多个实体类之间用逗号隔开。  \n`AppDatabase` 类必须继承自 `RoomDatabase` 类，并且一定要使用 `abstract` 关键字声明成抽象类，然后提供相应的抽象方法，用于获取之前的 `Dao` 实例，比如这里提供的 `userDao()` 方法。之后在 `companion object` 结构体中编写了一个单例模式，原则上全局应该只存在一个 `Appdatabase` 实例。  \n\n`databaseBuilder()` 方法接收三个参数：\n* 第一个：参数一定要使用 `applicationContext` ，而不能使用普通 `context()` ，否则容易出现内存泄漏的情况。\n* 第二个：参数是 `AppDatabase` 的 `Class` 类型。\n* 第三个：参数是数据库名\n\n修改 `MainActivity` 中的代码：\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    ....\n    override fun onCreate(savedInstanceState: Bundle?) {\n        ....\n        val userDao = AppDatabase.getDatabase(this).userDao()\n        val user1 = User(\"Tony\",\"ll\",11)\n        val user2 = User(\"Tom\",\"SS\",22)\n        btn_addData.setOnClickListener {\n            thread {\n                user1.id = userDao.insetUser(user1)\n                user2.id = userDao.insetUser(user2)\n           }\n        }\n        btn_updateData.setOnClickListener {\n            thread {\n                user1.age = 33\n                userDao.updateUser(user1)\n            }\n        }\n        btn_deleteData.setOnClickListener {\n            thread {\n                userDao.deleteUserByLastName(\"SS\")\n            }\n        }\n        btn_queryData.setOnClickListener {\n            thread {\n                for (user in userDao.loadAllUser()) {\n                    Log.d(\"MainActivity\",user.toString())\n                }\n            }\n        }   \n    }\n}\n```\n在 `AddData` 的点击事件中将 `insertUser()` 方法返回的主键 `id` 值赋值给了原来的 `User` 对象。之所以这样是因为使用 `@Update`、`@Delete` 注解去更新和删除数据时都是基于这个 `id` 值来操作的。  \n由于数据库操作属于耗时操作，`Room` 默认不允许在主线程中进行数据库操作，因此上述的增删改查操作都放在了子线程中，不过为了方便调试，`Room` 还提供了一个更加简单的方法：\n```kotlin\nRoom.databaseBuilder(context.applicationContext, AppDatabase::class.java, \"app_database\")\n    .allowMainThreadQueries()\n    .build()\n```\n这样 `Room` 就允许在主线程进行数据库操作了，**不过建议只在测试环境使用**\n\n### Room 的数据库升级\n`Room` 在数据库升级方面设计得比价繁琐，并没有比原生的 `SQLiteDatabase` 简单到哪儿去。如果你目前还只是在开发测试阶段，不想编写那么繁琐的数据库升级逻辑，`Room` 提供了一个简单粗暴的方法：\n```kotlin\nRoom.databaseBuilder(aontext.applicationContext, AppDatabase::class.java. \"app_database\")\n    .fallbackToDestructiveMigration()\n    .build()\n```\n构建 `AppDatabase` 实例时加入了一个 `fallbackToDestructiveMigration()` 方法，这样只要数据库进行了升级，`Room` 就会将当前的数据库销毁，然后再重新创建，但这样做的问题也就显而易见，之前数据库中的数据也会全部丢失。\n\n下面是正规用法  \n我们先新建一个 Book 的实体类：\n```kotlin\n@Entity\ndata class Book(var nane:String, var price: Int) {\n\n    @PrimaryKey(autoGenerate = true)\n    var id : Long = 0\n}\n```\n然后创建一个 BookDao 接口，并在其中随意定义一些 API\n```kotlin\n @Dao\ninterface BookDao {\n\n    @Insert\n    fun insert(book: Book) : Long\n\n    @Query(\"select * from Book\")\n    fun loadAllBooks() : List<Book>\n}\n```\n修改 AppDatabase 中的代码：\n```kotlin\n@Database(version = 2, entities = [User::class, Book::class])\nabstract class AppDatabase : RoomDatabase() {\n\n    abstract fun userDao() : UserDao\n    abstract fun bookDao() : Book\n\n    companion object{\n\n        val MIGRATION_1_2 = object : Migration(1,2) {\n            override fun migrate(database: SupportSQLiteDatabase) {\n                database.execSQL(\"create table Book (id integer primary key autoincrement not null, name text not null, price integer not null\")\n            }\n        }\n\n        private var instance: AppDatabase? = null\n\n        @Synchronized\n        fun getDatabase(context: Context): AppDatabase {\n            instance?.let {\n                return it\n            }\n            return Room.databaseBuilder(context.applicationContext,\n                AppDatabase::class.java, \"app_database\")\n                .addMigrations(MIGRATION_1_2)\n                .build().apply {\n                    instance = this\n                }\n        }\n    }\n}\n```\n我们在 `@Database` 注释中将版本号升级到了 **2** ，并将 `Book` 嘞添加到了实体类声明中。  \n在`companion object` 结构体中，实现了一个 `Migration` 的匿名类，并传入了 **1** 和 **2** 这两个参数，表示当前数据库版本从 **1** 升级到 **2** 的时候就执行这个匿名类中的升级逻辑。这里是要新增一张 `Book` 表，所以需要在 `migrate()` 方法中编写相应的建表语句。`Book` 表的建表语句必须和 `Book` 实体类中声明的结构完全一致。最后在构建 `AppDatabase` 实例时，加入一个 `addMigrations()` 方法，并将参数传入即可。  \n\n当我们的数据库可能不需要新建表，而是添加一个列时，可以使用 `alter` 语句修改表结构即可，如下：\n```kotlin\n@Entity\ndata class Book(var nane:String, var price: Int, var pages: Int) {\n    @PrimaryKey(autoGenerate = true)\n    var id : Long = 0\n}\n```\n这里添加了一个页数 `pages` 的字段，之后修改 `AppDatabase` 的代码：\n```kotlin\n@Database(version = 2, entities = [User::class, Book::class])\nabstract class AppDatabase : RoomDatabase() {\n    ....\n    companion object{\n        ....\n        var MIGRATION_2_3 = object : Migration(2, 3) {\n            override fun migrate(database: SupportSQLiteDatabase) {\n                database.execSQL(\"alter table Book add column pages integer not null default 'unknown'\")\n            }\n        }\n                private var instance: AppDatabase? = null\n\n        @Synchronized\n        fun getDatabase(context: Context): AppDatabase {\n            ....\n            return Room.databaseBuilder(context.applicationContext,\n                AppDatabase::class.java, \"app_database\")\n                .addMigrations(MIGRATION_1_2,MIGRATION_2_3)\n                .build().apply {\n                    instance = this\n                }\n        }\n    }\n}\n```\n升级步骤和之前差不多，就不多说了\n\n# WorkManager\n`WorkManager` 适合用于处理一些要求定时执行的任务，它可以根据操作系统的版本自动选择底层是使用 `AlarmManager` 实现还是 `JobScheduler` 实现，而且它还支持周期性任务、链式任务处理等功能。  \n\n`WorkManager` 的基本用法主要分以下三步：  \n1. 定义一个后台任务，并实现具体的任务逻辑；\n2. 配置该后台任务的运行条件和约束信息，并构建后台任务请求；\n3. 将改后台任务请求传入 `WorkManager` 的 `enqueue()` 方法中，系统会在合适的时间运行。\n\n下面来按照以上步骤来实现。第一步，定义一个后台任务，新建一个 `SimpleWorker` 类，如下：\n```kotlin\nclass SimpleWorker(context: Context, params: WorkerParameters) : Worker(context,params) {\n    override fun doWork(): Result {\n        Log.d(\"SimpleWorker\", \"do work in SimpleWorker\")\n        return Result.success()\n    }\n}\n```\n每一个后台任务都必须继承 `Work` 类。`doWork()` 方法不会运行在主线程中，因此可以在这里执行耗时操作，另外该方法要求返回一个 `Result` 对象，用于表示任务的运行结果。成功就是 `Result.success()` ，失败是 `Result.failure()` 。除了这两种还有一个 `Result.retry()` 方法，它其实也代表着失败，只是可以结合 `WorkRequest.Builder` 的 `setBackoffCriteria()` 方法来重新执行任务。\n\n第二步，配置该后台任务的运行条件和约束信息。  \n这里进行最基本的配置，代码如下：\n```kotlin\nvar request= OneTimeWorkRequest.Builder(SimpleWorker::class.java).build()\n```\n`OneTimeWorkRequest.Builder` 是 `WorkRequest.Builder` 的子类，用于构建单词运行的后台任务请求，还有另一个 `PeriodicWorkRequest.Builder` 也是其子类，用于构建周期性运行的任务请求，但为了降低设备性能消耗，它的构造函数中传入的运行周期间隔不能短于 15 分钟，实例如下：\n```kotlin\nvar request = PeriodicWorkRequest.Builder(SimpleWorker::class.java, 15,\n    TimeUnit.MINUTES).build()\n```\n\n第三步，最后只需要将构建好的后台任务请求传入 `WorkManager` 的 `enqueue()` 方法中，系统就会在合适的时间去运行了：\n```kotlin\nWorkManager.getInstance(context).enqueue(request)\n```\n下面来测试下，修改 `MainActivity` 中的代码：\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    ....\n    override fun onCreate(savedInstanceState: Bundle?) {\n        ....\n        btn_doWork.setOnClickListener {\n            val request= OneTimeWorkRequest.Builder(SimpleWorker::class.java).build()\n            WorkManager.getInstance(this).enqueue(request)\n        }\n    }\n}\n```\n这里后台任务的具体时间由我们所指定的约束以及系统的一些优化所决定的，由于这里没有指定任何约束，因此后台任务基本上会在点击按钮之后立刻运行。\n\n## 使用 WorkManager 处理复杂任务\n让后台任务在指定的延迟时间后运行，可以借助 `setInitialDelay()` 方法，如下：\n```kotlin\nvar request = PeriodicWorkRequest.Builder(SimpleWorker::class.java)\n    .setInitialDelay(5, TimeUnit.MINUTES)\n    .build()\n```\n`setInitalDelay()` 接收两个参数，第一个是要延迟的时间，第二个是该时间的单位：可以选择毫秒、秒、分钟、小时、天都可以。\n\n可以控制运行时间之后，再来添加点别的功能，比如给后台任务请求添加标签，如下所示：\n```kotlin\nvar request = PeriodicWorkRequest.Builder(SimpleWorker::class.java)\n    ....\n    .addTag(\"simple\")\n    .build()\n```\n该功能最主要的一个功能就是通过标签来取消后台任务请求：\n```kotlin\nWorkManager.getInstance(this).cancelAllWorkByTag(\"simple\")\n```\n使用标签可以将可以将同一标签名的所有后台请求全部取消  \n\n如果没有标签，也可以通过 id 来来取消后台任务请求：\n```kotlin\nWorkManager.getInstance(this).cancelAllWorkById(request.id)\n```\n\n如果想要一次性取消所有后台任务：\n```kotlin\nWorkManager.getInstance(this).cancelAllWork()\n```\n\n在上文中提到，如果 `doWork()` 方法中返回了 `Result.retry()`，那么可以结合 `setBackoffCriteria()` 方法来重新执行任务，如下：\n```kotlin\nvar request = PeriodicWorkRequest.Builder(SimpleWorker::class.java)\n    ....\n    .setBackoffCriteria(BackoffPolicy.LINEAR, 10, TimeUnit.SECONDS)\n    .build()\n```\n`setBackoffCriteria()` 接收三个参数：\n* 第一个：参数用于指定如果任务再次执行失败，下次重试的时间应该以什么样的形式延迟。该参数可选值有两种：\n    * LINEAR：表示下次重试时间以线性的方式延迟。\n    * EXPONENTIAL：表示下次重试的时间以指数的方式延迟。\n* 第二个和第三个都用于指定在多久之后重新执行任务，时间最短不能少于 10 秒钟\n\n接下来我们也可以对 `Result.success(`) 和 `Result.failure()` 任务结果进行监听，如下：\n```kotlin\nWorkManager.getInstance(this)\n    .getWorkInfoByIdLiveData(request.id)\n    .observe(this) { workInfo -> \n        if(workInfo.state == WorkInfo.State.SUCCEEDED) {\n            Log.d(\"MainActivity\", \"do work succeeded\")\n        } else if(workInfo.state == WorkInfo.State.FAILED) {\n            Log.d(\"MainActivity\". \"do work failed\")\n        }\n    }\n```\n这里调用了 `getWorkInfoByIdLiveData()` 方法，并传入后台任务请求的 `id` ，会返回一个 `LiveData` 对象，接着就可以调用 `LiveData` 对象的 `observe()` 方法来观察数据变化了，以此监听后台任务的运行结果。\n\n另外，调用 `getWorkInfoByTagLiveData()` 方法也可以监听同一标签名下所有后台任务请求的运行结果，用法差不多。\n\n## 链式任务\n假设定义了 3 个独立的后台任务：同步数据、压缩数据、上传数据，现在要实现先同步、再压缩、对吼上传的功能，就可以借助链式任务来实现，如下：\n```kotlin\nval sync = ....\nval compress = ....\nval upload = ....\nWorkManager.getInstance(this)\n    .beginWith(sync)\n    .then(compress)\n    .then(upload)\n    .enqueue()\n```\n`beginWith()` 方法用于开启一个链式任务，后面要执行的任务只需要使用 `then()` 方法来连接即可。  \n另外，`WorkManager` 还要求，必须在前一个后台任务运行成功之后，下一个后台任务才会运行，也就是说，如果某一个任务运行失败、或者取消了，之后的任务就都不能运行了\n\n以上介绍的 `WorkManager` 的所有功能，在国产手机上都有可能得不到正确的运行，因为绝大多数的国产手机厂商在进行 `Android` 系统定制时会增加一个一键关闭的功能，允许用户一键杀死所有非白名单的应用程序，而被杀死的应用程序既无法接收广播，也无法运行 `WorkManager` 的后台任务，所有千万别依赖 `WorkManager` 去实现什么核心功能，因为它在国产手机上可能会非常不稳定\n\n更多文章：  \n[Kotlin学习知识点整理-基础篇-01](https://juejin.im/post/6891231633702125576)  \n[Kotlin学习知识点整理-基础篇-02](https://juejin.im/post/6891260438219227143)  \n[Kotlin学习知识点整理-基础篇-03](https://juejin.im/post/6891621855204786184)  \n[Kotlin学习知识点整理-进阶篇-04](https://juejin.im/post/6892393981695819789)\n\n>写在最后唠唠《一日重生》佳句分享  \n>Going back to something is harder than you think.  \n>回到过去，比你想象的更难。","tags":["kotlin","Android","JetPack"],"categories":["Android"]},{"title":"Kotlin学习-进阶篇-04","url":"/2020/11/07/Kotlin学习-进阶篇-04/","content":"![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac070a7c9c2a45369fe732e7f887723d~tplv-k3u1fbpfcp-watermark.image)\n# Kotlin知识点整理进阶\n>本文是我在学习Kotlin的过程中整理的一些知识点，如有错误，欢迎指正\n## 一、字符串内嵌表达式\n语法规则：\n```kotlin\n\"hello ${obj.name}, nice to meet you\"\n```\n当表达式中只有一个变量时可将 `{}` 大括号省去\n\n## 二、函数的参数默认值\n示例如下：\n```kotlin\n//给第二个参数赋默认值\nfun printParam(num:Int,str:String = \"hello\"){\n    println(\"num is $num, str is $str\")\n}\n//调用\nprintParam(123)\n```\n因为 `str` 参数已经有了一个默认值 `”hello“` 所以**当调用时不传**第二个参数的话便会使用该参数的默认值\n```kotlin\n//给第一个参数赋默认值时\nfun printParam(num:Int = 123, str:String){\n    println(\"num is $num, str is $str\")\n}\n//调用 \nprintParam(str = \"hello\")\n```\n\n## 三、定义静态方法\n### 1、单例类\n示例如下：\n```kotlin\nobject Util{\n    fun doAction(){\n        println(\"do action\")\n    }\n}\n//调用方法\nUtil.doAction\n```\n事实上这里的 `doAction()` 并不是真正意义上静态方法，使用单例类的写法会将整个类中的所有方法**全部变成类似于静态方法**的调用方式。\n\n### 2、companion object\n示例如下：\n```kotlin\nclass Util {\n    fun doAction1(){\n        println(\"do action 1\")\n    }\n    companinon object{\n        fun doAction2(){\n            println(\"do action 2\")\n        }\n    }\n}\n```\n`doAction1()` 方法是一定要先创建 `Util` 类的实例才能调用， `doAction2()` 方法可以直接使用`Util.doAction2()` 方式调用  \nTIps：`doAction2()` 方法其实也并不是静态方法，`companinon object` 这个关键字实际上会在 `Util` 类的内部创建一个伴生类，而 `doAction2()`方法就是定义在这个伴生类中的实例方法，Kotlin会保证 `Util` 类始终只会存在一个伴生类对象，所以实际上就是调用了 `Util` 类中伴生对象的`doAction2()`方法\n\n### 3、注解：@JvmStatic\nKotlin 编译器会将使用该注解的方法编译成真正的静态方法，示例如下：\n```kotlin\nclass Util {\n    fun doAction1(){\n        println(\"do action 1\")\n    }\n    companinon object{\n        @JvmStatic  //该注解只能加在单例类或 companion object 中的方法上\n        fun doAction2(){\n            println(\"do action 2\")\n        }\n    }\n}\n```\n现在 `doAction2()` 方法已经是真正的静态方法了，现在不管在Java或是Kotlin中都可以使用 `Util.doAction2()`的写法来调用\n\n### 4、顶层方法\n**Kotlin 编译器会将所有的顶层方法全部编译成静态方法，故只要定义了一个顶层方法，那么它就一定是静态方法。**  \n创建方法：  \n1、创建 Kotlin 文件，创建类型要选择File。  \n2、在创建的文件中定义一个方法，如 `doSomething()` 方法，如下：\n```kotlin\nfun doSomething(){\n    println(\"do something\")\n}\n//在Kotlin中调用\ndoSomething()\n//在java中调用\nFileNameKt.doSomething()\n```\nKotlin 编译器会自动创建一个叫做 `FileNameKt` 的Java类\n\n## 四、密封类\n为了解决由于要满足编译器的要求而编写无用的条件分支的情况，在Kotlin中可使用密封类  \n密封类关键字是：`sealed class`  示例如下：\n```kotlin\nsealed class Result\nclass Success(val msg:String) : Result()\nclass Failed(val error:Exception) : Result()\n//由于密封类是一个可继承类，因此在继承它时需要在后面加一对括号\n```\n**注意**：密封类及其所有子类只能定义在同一文件的顶层位置\n\n## 五、扩展函数\n扩展函数表示即使在不修改某个类的源码的情况下，任然可以打开这个类，向该类添加新函数  \n扩展函数语法结构，示例如下：\n```kotlin\nfun className.methodName(params:Int, params:Int) : Int{\n    return 0\n}\n```\n例子:统计字符串中的字母的数量，如下：\n```kotlin\nfun String.letterCount() : Int {\n    var count = 0\n    for(char in this){\n        if(char.isLetter()){\n            count++\n        }\n    }\n    return count\n}\nvar count = \"abcd12345EFG\".letterCount()\n```\n更多文章：  \n[Kotlin学习知识点整理-基础篇-01](https://juejin.im/post/6891231633702125576)  \n[Kotlin学习知识点整理-基础篇-02](https://juejin.im/post/6891260438219227143)  \n[Kotlin学习知识点整理-基础篇-03](https://juejin.im/post/6891621855204786184)  \n[Kotlin学习知识点整理-进阶篇-04](https://juejin.im/post/6892393981695819789)\n>写在最后  \n>《一日重生》佳句分享：  \n>I could barely make it move. But her arm went across my chest and I sensed her carrying me once more, air passing over my face. I saw only darkness, as if we were traveling behind the length of a curtain. The the dark pulled away and there were stars. Thousands of them. She was laying me down in wet grass, returning my ruined soul to this world.  \n>我几乎不能动弹。但妈妈的手臂环绕着我，我再一次感觉她抱起了我，空气划过我的脸庞。我看到的只有黑暗，好像我们在一个长长的黑幕布后飞行。突然间，黑幕布拉开了，我的眼前出现了星星。成千上百的星星。她放下我，让我躺在湿漉漉的草地上，把我受伤的心还给这个世界。\n","tags":["kotlin","笔记","阅读"],"categories":["Kotlin"]},{"title":"Kotlin学习-基础篇-03","url":"/2020/11/05/Kotlin学习-基础篇-03/","content":"![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1aa72c86f8849039b9b4d4c87cf1bf2~tplv-k3u1fbpfcp-watermark.image)\n# Kotlin 的内置扩展函数\n>本文是我在学习Kotlin的过程中整理的一些知识点，如有错误，欢迎指正\n### 1、let\n\n示例代码如下：\n```kotlin\nobj.let { obj2 ->\n    //业务逻辑\n}\n```\n将原始调用对象作为参数传递到 Lambda 表达式中，可配合 `?.`操作符进行辅助判空处理\n\n### 2、with\n\n**`with`** 接收两个参数，第一个参数可以是一个任意类型的对象，第二个参数是一个**Lambda**表达式，  \n**`with`** 函数会在 **Lambda** 表达式中提供第一个参数对象的上下文，并使用**Lambda**表达式中的最后一行作为返回值返回，示例如下：\n\n```kotlin\nval result = with(obj) {\n    //这里式obj的上下文\n    \"value\" //最后一行 with 函数的返回值\n}\n```\n可连续调用同一个对象的多个方法\n\n### 3、run\n\n与 **`with`** 函数较为相似，**`run`** 函数不能直接嗲用，而是一定要调用某个对象的 **`run`** 函数才行，**`run`** 函数只接受一个 **Lambda** 参数，并且会在 **Lambda **表达式中提供调用对象的上下文，会使用 **Lambda** 表达式的最后一行作为返回值，示例代码如下：\n\n```kotlin\nval result = obj.run{\n     //这里式obj的上下文\n    \"value\" //最后一行 with 函数的返回值\n}\n```\n\n### 4、apply\n\n与 **`run`** 函数极为相似，需在某个对象上调用，只接收一个 **Lambda** 参数，在**Lambda**表达式中提供调用对象的上下文，**`apply`** 函数无法指定返回值，**而是会自动返回调用对象本身，**示例代码如下：\n\n```kotlin\nval result = obj.apply{\n    //这里式obj的上下文\n}\n// result == obj\n```\n\n### 5、repeat\n\n**`repeat`** 接收两个参数，第一个参数是一个 **`Int`** 类型的参数，用于指定循环次数。第二个参数是一个 Lambda 表达式。  \n**`repeat`** 可以将其中的 **Lambda** 表达式重复执行指定的次数。  \n示例如下：\n\n```kotlin\n repeat(4) { it ->\n       println(\" it = $it\")\n }\n//运行结果\nit = 0\nit = 1\nit = 2\nit = 3\n```\n更多文章：  \n[Kotlin学习知识点整理-基础篇-01](https://juejin.im/post/6891231633702125576)  \n[Kotlin学习知识点整理-基础篇-02](https://juejin.im/post/6891260438219227143)  \n[Kotlin学习知识点整理-基础篇-03](https://juejin.im/post/6891621855204786184)  \n[Kotlin学习知识点整理-进阶篇-04](https://juejin.im/post/6892393981695819789)\n>写在最后  \n>《一日重生》佳句分享：  \n>I feel ashamed now that I tried to take my life. It is such a precious thing. I had no one to talk me out of my despair, and that was a mistake. You need to keep people close. You need to give them access to your heart.  \n>我曾经试图结束自己的生命，我对此感到羞愧。生命宝贵无比。我没有找任何人谈心，排解我的绝望，这是不对的。你需要与人亲近，你得让他们接近你的心。\n\n","tags":["kotlin","笔记","阅读"],"categories":["Kotlin"]},{"title":"Kotlin学习-基础篇-02","url":"/2020/11/04/Kotlin学习-基础篇-02/","content":"![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cadc0205934a440cb769ef810dac9eb1~tplv-k3u1fbpfcp-watermark.image)\n# Lambda编程\n>本文是我在学习Kotlin的过程中记录的一些知识点，如有错误，欢迎指正\n## 集合的创建与遍历\n**List集合**  \n使用Kotlin内置的 `listof()` 简化初始化集合，示例如下：\n```kotlin\nval list = listOf(\"Apple\",\"Banana\",\"Orange\",\"Pear\",\"Grape\")\n```\n`listOf()`创建的是一个不可变集合，不可变集合指只能用于读取，不能进行添加、修改、删除等操作  \n使用 `mutableListOf()` 函数创建可变集合，示例如下：\n```kotlin\nval list = mutableListOf(\"Apple\",\"Banana\",\"Orange\",\"Pear\",\"Grape\")\nlist.add(\"Watermelon\") //可以进行添加等操作\n```\n\n**Set集合**  \n`set`集合的创建和List类似，也有 `setOf()` 和 `muatbleSetOf()`,使用方法相同。  \n`set`集合底层时使用hash映射机制来存放数据的，因此集合中各大元素无法保证有序\n\n**Map集合**  \n`Map`集合是一种键值对形式的数据结构  \nKotlin中不建议使用`put()`和`get()`方法来对Map进行添加和读取数据操作  \n`Msp`集合基础实现，如下:\n```kotlin\nval map = HashMap<String,Int>\nmap[\"Apple\"] = 1\nmap[\"Banana\"] = 2\n...\n```\n`mapOf()`和`mutableMapOf()`使用和前面一致，如下：\n```kotlin\nval map = mapOf(\"Apple\" to 1, \"Banana\" to 2, ...)\n```\n注，`to`不是关键字，而是一个`infix`函数\n\n## 集合函数式 API\n`Lambda`就是一小段可以作为参数传递的代码  \n语法结构如下：\n```\n{参数名1:参数类型, 参数名2:参数类型 -> 函数体}\n```\n解释：如果有参数传入到 Lambda 表达式中的话，需要声明参数列表，参数列表结尾使用一个 `->` 符号，表示参数列表的结束以及函数体的开始，函数体中最后一行代码为自动作为 Lambda 表达式的返回值  \n示例如下：\n```kotlin\nvar maxLengthString = list.maxBy({string:String -> string.length})\n```\n1、当Lambda参数是函数的最后一个参数时，可将Lambda表达式移到函数括号的外面  \n2、当Lambda参数是函数的唯一一个参数时，可将括号省略  \n3、当Lambda表达式的参数列表中只有一个参数时，可不必声明参数名，可以使用it关键字代替  \n最后如下：\n```kotlin\nvar maxLengthString = list.maxBy{it.length}\n```\n### 常用函数式 API\n#### maxBy()\n接收一个 Lambda 类型参数，在遍历集合时将每次遍历的值作为参数传给 Lambda 表达式。\n根据我们传入的条件来遍历集合，从而找到该条件下的最大值  \n示例，找到集合中字符串最长的一个：\n```kotlin\nvar maxLengthString = list.maxBy{it.length}\n```\n\n#### map()\n接收一个 Lambda 类型参数，将集合中的每个元素都映射成一个另外的值，映射的规则在 Lambda 表达式中指定，最终生成一个新的集合。  \n示例：将集合中的字母都变成大写：\n```kotlin\nvar upperCase = list.map{it.toUpperCase() }\n```\n\n#### filter()\n用于过滤集合中的数据可单独使用，也可配合其他函数（如`map`函数）一起使用  \n示例，保留5个字母以内的单词：\n```kotlin\nvar newList = list.filter{it.length <= 5 }\n                  .map{it.toUpperCase() }\n```\n\n#### any()\n用于判断集合中是否至少存在一个元素满足条件  \n示例，是否存在5个字母以内的单词\n```kotlin\nval list = listOf(\"Apple\",\"Banana\",\"Orange\",\"Pear\",\"Grape\")\nvar anyResult = list.any{it.length <=5 }\n//运行结果为 true\n```\n\n#### all()\n用于判断集合中是否所有元素都满足指定条件  \n示例，是否所有单词都在5个字母以内\n```kotlin\nval list = listOf(\"Apple\",\"Banana\",\"Orange\",\"Pear\",\"Grape\")\nvar anyResult = list.all{it.length <=5 }\n//运行结果为 false\n```\n\n## Java 函数式 API\n当在 Kotlin 中调用一个 Java 方法，并且该方法接收一个**Java单抽象方法接口参数**，就可使用函数式 API  \n示例，Java 中最常见的单抽象方法接口--`Runnable`接口，在 Kotlin 中的写法如下：\n```kotlin\nThread(object : Runnable{  //创建匿名类实例改用object关键字\n    override fun run(){....}\n}).start()\n```\n因为 Thread 类的构造方法符合 Java 函数式 API 的使用条件，可简化为：\n```kotlin\nThread(Runnable {  //Runnable类中只有一个待实现方法，故可不显示重写run()方法\n    ....\n}).start()\n```\n当一个 Java 方法的**参数列表不存在一个以上 Java 单抽象方法接口**时可以将接口名省略，如下所示：\n```kotlin\nThread{....}.start()\n```\nAndroid 中最为常用的 Java 单抽象方法接口，`OnClickListener`，在 Kotlin 中可这样写：\n```kotlin\nbutton.setOnClickListener{.....}\n```\nJava 函数式 API 的使用都**仅限于从 Kotlin 中调用 Java 方法，并且单抽象方法接口也是用 Java 定义**的。\n\n## 空指针检查\n### `?` 操作符\n Kotlin 中**默认所有参数和变量都不可为空。**  \n可为空类型系统可以让需要的变量或参数为空，如下：\n```kotlin\nvar int:Int?\nvar string:String?\nvar c:ClassName?\n```\n `?` 符号表示该类型的变量可为空  \n**注意，使用可为空类型的参数或变量时需将空指针异常进行处理**\n\n###  `?.` 操作符\n结合上述的 `?` 操作符一起使用时，如下：\n```kotlin\nfun doSomething(study:Study?){\n    study?.doHomework()\n    study?.readBook()\n}\n```\n当对象不为空时正常调用相应方法，为空时什么都不做  \n\n### `?:` 操作符\n这个操作符左右两边都接收一个表达式，如果**左边的表达式不为空则返回左边的结果**，**否则返回右边的表达式的结果**，示例如下：\n```kotlin\nvar c = if(a! = null){\n    a\n} else {\n    b\n}\n//以上运用?:操作符可简化为\nvar c = a ?: b\n```\n将 ?. 和 ?: 结合使用，示例如下\n```kotlin\nfun getTextLength(text:String?) = text?.length() ?: 0\n```\n\n### 非空断言工具 `!!`\n在一些情况下，当你非常确定变量不会为空时，为了通过编译器的限制，在对象后面加上 `!!` 可断言该对象不为空，强行通过编译\n\n更多文章：  \n[Kotlin学习知识点整理-基础篇-01](https://juejin.im/post/6891231633702125576)  \n[Kotlin学习知识点整理-基础篇-02](https://juejin.im/post/6891260438219227143)  \n[Kotlin学习知识点整理-基础篇-03](https://juejin.im/post/6891621855204786184)  \n[Kotlin学习知识点整理-进阶篇-04](https://juejin.im/post/6892393981695819789)\n>写在最后  \n>分享一些话：有些时候，当你所处的环境，都像一艘船一样沉下去的时候，你仍需知道，你最大，最优先的责任，是要先救起你自己","tags":["kotlin","笔记","阅读"],"categories":["Kotlin"]},{"title":"Kotlin学习-基础篇-01","url":"/2020/11/04/Kotlin学习-基础篇-01/","content":"\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b51ce98510514b319952f3713eba566c~tplv-k3u1fbpfcp-watermark.image)\n\n# Kotlin学习-基础篇\n>本文是本人在学习 Koitlin 期间记录的一些知识点，仅作参考，如有错误，欢迎指正\n## 1、变量\n`val` (value的简写) 用来声明一个不可变的变量，对应Java中的 `final` 变量  \n`var` (variable的简写) 用来声明一个可变的变量，对应Java中的非 `final` 变量  \n当Kotlin无法自动推导变量类型时，需要显示声明变量类型，如：\n```kotlin\nval a: Int = 10\n```\nJava和Kotlin数据类型对照表：\n| Java基本数据类型 | Kotlin对象数据类型 | 数据类型说明 |\n| :------------: | :----------------: | :---------: |\n| int | Int | 整型 |\n| long | Long | 长整型 |\n| short | Short | 短整型 |\n| float | Float | 单精度浮点型 |\n| double | Double | 双精度浮点型 |\n| boolean | Boolean | 布尔型 |\n| char | Char | 字符型 |\n| byte | Byte | 字节型 |\n\n### 变量延迟初始化\n`lateinit`可以告诉`Kotlin`编译器我会晚些时候对其进行初始化，避免一开始声明变量时需赋值为空，示例如下：\n```kotlin\nclass Class1 {\n    private lateinit var params: Params\n    fun doSomthing(){\n        if(!::params.isInitialized){\n        params = Params(...)\n        }\n    }\n}\n```\n为了避免因变量没有初始化导致程序崩溃，故通过，`::params.isInitialized`来判断变量是否已经初始化\n\n## 2、函数\n自定义函数，语法规则如下：\n```kotlin\nfun methodName(param1:Int, param2:Int):Int{\n    return 0\n}\n//Kotlin函数语法糖,当函数只有一行代码时，可省去return关键字，等号可表示返回值的意思\nfun methodName(param1:Int, param2:Int):Int = 0\n```\n\n## 3、if 条件语句\n`Kotlin` 中的 `if`  语句相比于 Java 有一个额外功能，它可以有返回值  \n`if` 语句中每一个条件中最后一行代码可作为返回值，如下：\n```kotlin\nfun methodName(param1:Int, param2:Int):Int{\n    return if(param1 > param2){\n        param1\n    } else{\n        param2\n    }\n}\n//Kotlin语法糖..简化为\nfun methodName(param1:Int, param2:Int):Int = if (param1 > param2) param1 else param2\n```\n\n## 4、when 条件语句\n`when`语句允许掺入一个任意类型的参数，然后可以在`when`的结构体中定义一系列条件。\n格式为：  \n```\n匹配值 -> {执行逻辑}\n```\n示例，不同学生对应不同分数：\n```kotlin\nfun getScore(name:String) = when(name){\n    \"Tom\" -> 60\n    \"Jim\" -> 30\n    \"Tommy\" -> 50\n    \"Lily\" -> 70\n    else -> 0\n}\n//当执行逻辑里只有一行代码时可省去{}，且when语句也将最后一行作为返回值\n```\n`when` 不带参数的用法，示例：\n```kotlin\nfun getScore(name:String) = when{\n    name == \"Tom\" -> 60\n    name == \"Jim\" -> 30\n    name == \"Tommy\" -> 50\n    name == \"Lily\" -> 70\n//    name.startWith(\"Tom\") -> 80 //将以Tom开头的名字，分数都为80\n    else -> 0\n}\n```\nwhen语句也可用作类型匹配，示例：\n```kotlin\nfun checkNumber(num:Number){\n    when(num){\n        is Int -> println(\"Number is Int\")\n        is Double -> println(\"Number is Bouble\")\n        ....\n        else -> (\"Number not support\")\n    }\n}\n```\n\n## 5、循环语句\n### 区间\nKotlin中创建一个区间：  \n双端闭区间，如下：\n```kotlin\nval range = 0..10\n//表示创建了一个从0到10 的区间，并且两端都是闭区间，数学式为[0,10]\n//其中 .. 是创建双端闭区间的关键字\n```\n单端闭区间，如下：\n```kotlin\nval range = 0 until 10\n//表示创建了一个 从0到10的左闭右开区间，数学式为[1,10)\n//其中 until 是创建单端闭区间的关键字\n```\n注意：使用 `..` 和 `until` 关键字都要求左端小于等于右端\n\n降序区间，如下：\n```kotlin\nval range = 10 downTo 1\n//表示创建了一个从10到1的区间，数学式表示为[10,1]\n//downTo是创建降序区间的关键字\n```\n\n### for-in 循环\n示例如下：\n```kotlin\nfor (i in 0..10){\n    ....\n}\n//表示遍历这个从0到10的闭区间\n```\n由于 `for-in` 循环每次执行循环时区间范围递增 1，所以可使用 `step` 关键字来跳过一些元素\n示例如下：\n```kotlin\nfor (i in 0..10 step 2){\n    ....\n}\n//表示每次执行循环递增2\n```\n\n## 6、面向对象\n### 类与对象\nKotlin中创建一个对象，如下：\n```kotlin\nclass ClassName{\n}\n```\n对这个类进行实例化，如下：\n```kotlin\nval c = ClassName()\n```\n\n### 类与构造对象\n在Kotlin中任何一个非抽象类默认都是不可被继承的  \n使类可以被继承，如下：\n```kotlin\nopen class ClassName{\n}\n//加上open关键字使类可被继承\n```\n让一个类去继承另一个类，如下：\n```kotlin\nclass class1 : class2(){\n}\n```\n\nKotlin中的构造函数分为**主构造函数**和**次构造函数**  \n每一个类默认都会有一个不带参数的主构造函数，可显式地指定参数。 \n\n主构造函数特点没有函数体，直接定义在类名后面即可，如下：\n```kotlin\nclass class1(val params1:String, val params2:Int){\n}\n```\n实例化，如下：\n```kotlin\nval c = class1(\"Hello\",10)\n```\n\n当需要在主构造函数中编写一些逻辑时，  \nKotlin提供了一个 `init` 结构体，可将主构造函数逻辑写在里面，如下：\n```kotlin\nclass class1(val params1:String, val params2:Int){\n    init{\n        prinln(params1 + params2)\n    }\n}\n```\n\n子类的构造函数必须调用父类中的构造函数，如下：\n```kotlin\n//父类\nopen class Class2(val name:String, val age:Int){\n}\n//子类\nclass Class1(val son:String, val grade:Int, name:String, age:Int) : \n        Class2(name, age){\n}\n//创建实例\nval c = Class1(\"a123\",2,\"Tom\",12)\n```\n注意，在`Class1`类中不能将`name`和`age`声明成`val`，因为在主构造函数中声明成`var`或`val`的参数将自动成为该类的字段。不加任何关键字，让它的作用域仅限定在主构造函数当中即可。\n\n次构造函数  \nKotlin规定，当一个类既有主构造函数也有次构造函数时，**所有的次构造函数都必须调用主构造函数**(包括间接调用)，示例如下：\n```kotlin\nclass Class1(val son:String, val grade:Int, name:String, age:Int):\n        Class2(name, age){\n    constructor(name:String,age:Int) : this(\"\",0,name,age){\n    }\n    constructor():this(\"\",0){\n    }\n}\n//分别调用构造函数进行实例化\nval c1 = Class1()\nval c2 = Class1(\"Tom\",19)\nval c3 = Class1(\"a123\",4,\"Tom\",19)\n```\n次构造函数通过`constructor`关键字来定义，这里定义的两个次构造函数。第一个接收的参数时`name`和`age`参数，又通过`this`关键字调用了主构造函数，并将`son`和`grade`这两个参数赋值为初始值；第二个个次构造函数不接收任何参数，通过`thsi`关键字调用了第一个次构造函数，并将参数赋值为初始值。第二个次构造函数间接调用了主构造函数，所以也是合法的.\n\n### 接口\nKotlin中让一个类实现一个接口以及实现接口中的方法，如下：\n```kotlin\nclass Class1() : Class2() , InterfaceName{\n    override fun doSomething(){\n    }\n}\n```\n实现接口使用逗号隔开，使用`override`关键字来重写父类或者接口中的函数\n\nKotlin中允许对接口中定义的函数进行默认实现，示例如下：\n```kotlin\ninterface InterfaceName{\n    fun doSomething(){\n        .....//执行逻辑\n    }\n}\n```\n如果接口中的函数有了函数体，这个函数体中的内容就是它的默认实现，一个类去实现该接口时，**会强制要求实现没有函数体的函数，不会强制要求实现有函数体的函数，不实现时就会自动使用默认的实现逻辑。**\n\n### 修饰符\nJava 和 Kotlin 函数可见性修饰符对照表\n| 修饰符 | Java | Kotlin |\n| :---: | :---: | :---: |\n| public | 所有类可见 | 所有类可见（默认）|\n| private | 当前类可见 | 当前类可见 |\n| protected | 当前类、子类、同一包路径下的类可见 | 当前类、子类可见 |\n| default | 同一包路径下的类可见（默认） | 无 |\n| internal | 无 | 同一模块中的类可见 |\n\n### 数据类与单例类\n数据类用于将服务器端或数据库中的数据映射到内存中，为编程逻辑提供数据模型的支持。  \nKotlin中创建数据类，示例如下：\n```kotlin\ndata class Cellphone(val brand:String, val price:Double)\n//使用上面这个数据类，如下\nfun main() {\n    val cellphone1 = Cellphone(\"Samsung\", \"1299.99\")\n    val cellphone2 = Cellphone(\"Samsung\", \"1299.99\")\n    println(cellphone1)\n    println(\"cellphone1 equals cellphone2\"+(cellphone1 == cellphone2))\n}\n//运行结果为\n//Cellphone(brand=Samsung, price=1299.99)\n//cellphone1 equals cellphone2 true\n```\n当在一个类前面声明`data`关键字时，便表明你希望这个类是一个数据类  \n当一个类中没有任何代码时，可以将大括号省略。\n\n单例类  \n用于保证某个类在全局最多只能拥有一个实例，不同于Java中实现单例模式的方式，在 Kotlin 中实现非常简单。  \nKotlin中创建单例类，创建类型选择“Object”，示例代码如下：\n```kotlin\nobject Singleton{\n    fun singletonTest(){\n        println(\"SingeltonTest is called\")\n    }\n}\n//调用单例类中的函数\nSingleton.singletonTest()\n```\n\n更多文章：  \n[Kotlin学习知识点整理-基础篇-01](https://juejin.im/post/6891231633702125576)  \n[Kotlin学习知识点整理-基础篇-02](https://juejin.im/post/6891260438219227143)  \n[Kotlin学习知识点整理-基础篇-03](https://juejin.im/post/6891621855204786184)  \n[Kotlin学习知识点整理-进阶篇-04](https://juejin.im/post/6892393981695819789)\n>写在最后：遨游在知识的海洋，永远对技术怀有一个敬畏之心\n","tags":["kotlin","笔记","阅读"],"categories":["Kotlin"]}]